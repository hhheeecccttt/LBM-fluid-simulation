<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin: 20px;
            background-color: #f4f4f4;
        }
        #simulationWrapper {
            border: 1px solid #ccc;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
        }
        canvas {
            background-color: #fff;
            display: block;
        }
        #controlPanel {
            border: 1px solid #ccc;
            padding: 15px;
            background-color: #fff;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .slider-panel {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-panel label {
            width: 120px;
            text-align: right;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="simulationWrapper">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <div id="controlPanel">
        <div class="button-group">
            <button id="toggleDrawLines">Toggle Draw Lines</button>
            <button id="resetSimulation">Reset Simulation</button>
            <button id="toggleObstacle">Toggle Obstacles</button>
            <button id="togglePlot">Toggle Plot (Density / Speed)</button>
        </div>

        <div class="slider-panel">
            <label for="densityVariationSlider">Density Variation:</label>
            <input type="range" id="densityVariationSlider" min="0" max="10" value="3">
        </div>
        <div class="slider-panel">
            <label for="flowSpeedSlider">Flow Speed:</label>
            <input type="range" id="flowSpeedSlider" min="0" max="10" value="1">
        </div>
        <div class="slider-panel">
            <label for="viscositySlider">Viscosity:</label>
            <input type="range" id="viscositySlider" min="6" max="10" value="6">
        </div>
        <div id="performance">
            FPS: <span id="fps">0</span> | 
            Frame Time: <span id="frameTime">0</span>ms
        </div>
    </div>

    <script>
        class Simulation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                this.xDimension = 200;
                this.yDimension = 80;
                this.scale = 4;

                this.canvas.width = this.xDimension * this.scale;
                this.canvas.height = this.yDimension * this.scale;

                this.density = new Float32Array(this.xDimension * this.yDimension * 9);
                this.density2 = new Float32Array(this.xDimension * this.yDimension * 9);
                this.xVelocity = new Float32Array(this.xDimension * this.yDimension);
                this.yVelocity = new Float32Array(this.xDimension * this.yDimension);
                this.macroDensity = new Float32Array(this.xDimension * this.yDimension);
                this.barrier = new Uint8Array(this.xDimension * this.yDimension); 

                this.tau = 0.6;
                this.flowSpeed = 0.1;

                this.plot = 0;
                this.drawLines = true;
                this.densityVariation = 0.03;
                this.obstacle = 0;

                this.directionXVector = [0, 0, 0, 1, -1, 1, -1, -1, 1];
                this.directionYVector = [0, 1, -1, 0, 0, 1, -1, 1, -1];
                this.directionWeights = [4.0/9, 1.0/9, 1.0/9, 1.0/9, 1.0/9, 1.0/36, 1.0/36, 1.0/36, 1.0/36];
                this.threeTimesWeights = this.directionWeights.map(w => 3 * w);
                this.fourPointFiveTimesWeights = this.directionWeights.map(w => 4.5 * w);
                this.onePointFiveTimesWeights = this.directionWeights.map(w => 1.5 * w);
                this.oppositeDirection = [0, 2, 1, 4, 3, 7, 5, 6, 8];

                this.imageData = this.ctx.createImageData(this.xDimension, this.yDimension);
                this.pixels = new Uint32Array(this.imageData.data.buffer);

                this.frameCount = 0;
                this.lastFpsTime = performance.now();
                this.lastFrameTime = 0;
                
                this.initializeSimulation();
                this.animationFrameId = null;
                this.lastTime = 0;
                this.frameTime = 1000 / 60;
                this.stepsPerFrame = 10;
                this.startAnimation();
            }

            index3D(x, y, d) {
                return (x * this.yDimension + y) * 9 + d;
            }

            index2D(x, y){
                return (x * this.yDimension + y);
            }

            initializeSimulation() {
                this.barrier = this.drawBarriers(this.obstacle, this.xDimension, this.yDimension);
                for (let x = 0; x < this.xDimension; x++) {
                    this.barrier[this.index2D(x, 0)] = this.barrier[this.index2D(x, this.yDimension - 1)] = true;
                }

                const uX = this.flowSpeed;
                const uY = 0.0;
                for (let x = 0; x < this.xDimension; x++) {
                    for (let y = 0; y < this.yDimension; y++) {
                        if (!this.barrier[this.index2D(x, y)]) {
                            for (let d = 0; d < 9; d++) {
                                const eDotU = this.directionXVector[d] * uX + this.directionYVector[d] * uY;
                                const uSqr = uX * uX + uY * uY;
                                this.density[this.index3D(x, y, d)] = this.directionWeights[d] * (1 + 3 * eDotU + 4.5 * eDotU * eDotU - 1.5 * uSqr);
                            }
                        } else {
                            for (let d = 0; d < 9; d++) {
                                this.density[this.index3D(x, y, d)] = 0;
                            }
                        }
                    }
                }
            }

            resetSimulation() {
                this.density.fill(0);
                this.density2.fill(0);
                this.xVelocity.fill(0);
                this.yVelocity.fill(0);
                this.macroDensity.fill(0);
                this.barrier.fill(false);
                this.initializeSimulation();
            }

            collision() {
                const inverseTau = 1 / this.tau;
                const oneMinusInverseTau = 1.0 - inverseTau;
                for (let x = 0; x < this.xDimension; x++) {
                    const xOffset = x * this.yDimension;
                    for (let y = 0; y < this.yDimension; y++) {
                        const index2D = xOffset + y;
                        if (!this.barrier[this.index2D(x, y)]) {
                            const index3DBase = index2D * 9;
                            const index2DCache = this.index2D(x, y);
                            let totalDensity = 0;
                            let vX = 0;
                            let vY = 0;

                            const d0 = this.density[index3DBase];
                            const d1 = this.density[index3DBase + 1];
                            const d2 = this.density[index3DBase + 2];
                            const d3 = this.density[index3DBase + 3];
                            const d4 = this.density[index3DBase + 4];
                            const d5 = this.density[index3DBase + 5];
                            const d6 = this.density[index3DBase + 6];
                            const d7 = this.density[index3DBase + 7];
                            const d8 = this.density[index3DBase + 8];

                            totalDensity = d0 + d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8;
                            vX = d3 - d4 + d5 - d6 - d7 + d8;
                            vY = d1 - d2 + d5 - d6 + d7 - d8;

                            this.macroDensity[index2D] = totalDensity;

                            if (totalDensity > 1e-6) {
                                vX /= totalDensity;
                                vY /= totalDensity;
                            }
                            this.xVelocity[index2DCache] = vX;
                            this.yVelocity[index2DCache] = vY;

                            const uSquared = vX * vX + vY * vY;
                            const oneMinusOnePointFiveUSquared = 1 - 1.5 * uSquared;

                            for (let d = 0; d < 9; d++) {
                                const dotProduct = this.directionXVector[d] * vX + this.directionYVector[d] * vY;
                                const equilibriumDensity = totalDensity * this.directionWeights[d] * (oneMinusOnePointFiveUSquared + 3 * dotProduct + 4.5 * dotProduct * dotProduct);
                                this.density[index3DBase + d] = oneMinusInverseTau * this.density[index3DBase + d] + inverseTau * equilibriumDensity;
                            }
                        }
                    }
                }
            }

            streamingAndBoundary() {
                for (let x = 0; x < this.xDimension; x++) {
                    const xOffset = x * this.yDimension;
                    for (let y = 0; y < this.yDimension; y++) {
                        const index2D = xOffset + y;
                        const index3DBase = index2D * 9;
                        if (this.barrier[index2D]) {
                            for (let d = 0; d < 9; d++) {
                                this.density2[index3DBase] = this.density[index3DBase + this.oppositeDirection[d]];
                            }
                            continue;
                        }

                        for (let d = 0; d < 9; d++) {
                            const prevX = x - this.directionXVector[d];
                            const prevY = y - this.directionYVector[d];

                            if (prevX >= 0 && prevX < this.xDimension && prevY >= 0 && prevY < this.yDimension) {
                                const prevIndex2D = prevX * this.yDimension + prevY;
                                if (!this.barrier[prevIndex2D]) {
                                    this.density2[index3DBase + d] = this.density[prevIndex2D * 9 + d];
                                } else {
                                    this.density2[index3DBase + d] = this.density[index3DBase + this.oppositeDirection[d]];
                                }
                            } else {
                                this.density2[index3DBase + d] = this.density[index3DBase + this.oppositeDirection[d]];
                            }
                        }
                    }
                }
                [this.density, this.density2] = [this.density2, this.density];
            }

            inlet() {
                const densityFlow = 1.0;
                const vYFlow = 0.0;
                const uSquared = this.flowSpeed * this.flowSpeed + vYFlow * vYFlow;

                for (let y = 0; y < this.yDimension; y++) {
                    if (!this.barrier[this.index2D(0, y)]) {
                        for (let d = 0; d < 9; d++) {
                            const dotProduct = this.directionXVector[d] * this.flowSpeed + this.directionYVector[d] * vYFlow;
                            this.density[this.index3D(0, y, d)] = this.directionWeights[d] * (densityFlow + 3 * dotProduct + 4.5 * dotProduct * dotProduct - 1.5 * uSquared);
                        }
                    }
                    if (!this.barrier[this.index2D(this.xDimension - 1, y)]) {
                        for (let d = 0; d < 9; d++) {
                            const dotProduct = this.directionXVector[d] * this.flowSpeed + this.directionYVector[d] * vYFlow;
                            this.density[this.index3D(this.xDimension - 1, y, d)] = this.directionWeights[d] * (densityFlow + 3 * dotProduct + 4.5 * dotProduct * dotProduct - 1.5 * uSquared);
                        }
                    }
                }
            }

            renderToImage() {
                const displayMaxSpeed = 0.2;
                for (let x = 0; x < this.xDimension; x++) {
                    for (let y = 0; y < this.yDimension; y++) {
                        let color;
                        if (this.barrier[this.index2D(x, y)]) {
                            color = 0xFF0000FF;
                        } else {
                            if (this.plot === 0) {
                                const normalizedSpeed = Math.sqrt(this.xVelocity[this.index2D(x, y)] * this.xVelocity[this.index2D(x, y)] + this.yVelocity[this.index2D(x, y)] * this.yVelocity[this.index2D(x, y)]) / displayMaxSpeed;
                                const intensity = Math.floor(Math.max(0.0, Math.min(1.0, normalizedSpeed)) * 255);
                                color = (0xFF << 24) | (intensity << 16) | (intensity << 8) | (intensity);
                            } else if (this.plot === 1) {
                                const dens = this.macroDensity[this.index2D(x, y)];
                                let intensity = Math.floor(((dens - (1 - this.densityVariation)) / (2 * this.densityVariation)) * 255);
                                intensity = Math.max(0, Math.min(255, intensity));
                                color = (0xFF << 24) | (intensity << 16) | (intensity << 8) | (intensity);
                            }
                        }
                        this.pixels[y * this.xDimension + x] = color;
                    }
                }
                this.ctx.putImageData(this.imageData, 0, 0, 0, 0, this.xDimension, this.yDimension);
            }

            drawBarriers(index, xDimension, yDimension) {
                const barrier = new Uint8Array(xDimension * yDimension);
                if (index === 0) {
                    for (let y = 25; y <= 55; y++) {
                        barrier[this.index2D(50, y)] = true;
                    }
                } else if (index === 1) {
                    const centerX = 50;
                    const centerY = 40;
                    const radius = 15;
                    for (let x = centerX - radius; x <= centerX + radius; x++) {
                        for (let y = centerY - radius; y <= centerY + radius; y++) {
                            if (x >= 0 && x < xDimension && y >= 0 && y < yDimension) {
                                const dx = x - centerX;
                                const dy = y - centerY;
                                if (dx * dx + dy * dy <= radius * radius) {
                                    barrier[this.index2D(x, y)] = true;
                                }
                            }
                        }
                    }
                } else if (index === 2) {
                    const pipeStart = 50;
                    const pipeEnd = 100;
                    const maxHalfHeight = 25;
                    const minHalfHeight = 15;
                    for (let x = pipeStart; x < pipeEnd; x++) {
                        const t = (x - pipeStart) / (pipeEnd - pipeStart);
                        const halfOpening = maxHalfHeight - (maxHalfHeight - minHalfHeight) * t;

                        const centerY = Math.floor(yDimension / 2);
                        const upperWall = centerY - Math.floor(halfOpening);
                        const lowerWall = centerY + Math.floor(halfOpening);

                        for (let y = 0; y < yDimension; y++) {
                            if (y === 0 || y === yDimension - 1) continue;
                            if (y <= upperWall || y >= lowerWall) barrier[this.index2D(x, y)] = true;
                        }
                    }
                }
                return barrier;
            }

            render() {
                this.renderToImage();
                this.ctx.drawImage(this.canvas, 0, 0, this.xDimension, this.yDimension, 0, 0, this.xDimension * this.scale, this.yDimension * this.scale);
                
                if (this.drawLines) {
                    this.ctx.strokeStyle = 'blue';
                    this.ctx.lineWidth = 1;

                    for (let x = 0; x < this.xDimension; x += 8) {
                        for (let y = 0; y < this.yDimension; y += 8) {
                            const index2D = x * this.yDimension + y;
                            if (!this.barrier[index2D]) {
                                let magnitudeScale = 0;
                                const magnitude = Math.sqrt(this.xVelocity[index2D] * this.xVelocity[index2D] + this.yVelocity[index2D] * this.yVelocity[index2D]);
                                const desiredMagnitude = 3;
                                if (magnitude > 0) {
                                    magnitudeScale = desiredMagnitude / magnitude;
                                }
                                const x1 = x * this.scale;
                                const y1 = y * this.scale;
                                const x2 = x1 + this.xVelocity[index2D] * magnitudeScale * this.scale;
                                const y2 = y1 + this.yVelocity[index2D] * magnitudeScale * this.scale;

                                this.ctx.beginPath();
                                this.ctx.moveTo(x1, y1);
                                this.ctx.lineTo(x2, y2);
                                this.ctx.stroke();
                            }
                        }
                    }
                }
            }
    
            updatePerformanceStats(timestamp) {
                this.frameCount++;
                const now = performance.now();
                const frameDelta = now - this.lastFrameTime;
                this.lastFrameTime = now;

                if (now - this.lastFpsTime > 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsTime));
                    document.getElementById('fps').textContent = fps;
                    document.getElementById('frameTime').textContent = frameDelta.toFixed(1);
                    this.frameCount = 0;
                    this.lastFpsTime = now;
                }
            }

            startAnimation() {
                const animate = (timestamp) => {
                    if (!this.lastTime) {
                        this.lastTime = timestamp;
                    }

                    const elapsed = timestamp - this.lastTime;
                    const numSteps = Math.floor(elapsed / this.frameTime);
                    const stepsToRun = Math.min(numSteps, this.stepsPerFrame);

                    for (let i = 0; i < stepsToRun; i++) {
                        this.updateSimulation();
                    }
                    this.lastTime += stepsToRun * this.frameTime;

                    this.render();
                    this.updatePerformanceStats(timestamp);
                    this.animationFrameId = requestAnimationFrame(animate);
                };
                this.animationFrameId = requestAnimationFrame(animate);
            }

            updateSimulation() {
                for (let n = 0; n < this.stepsPerFrame; n++){
                    this.inlet();
                    this.collision();
                    this.streamingAndBoundary();
                }
            }

            stopAnimation() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }
        }

        const simulation = new Simulation('simulationCanvas');

        document.getElementById('toggleDrawLines').addEventListener('click', () => {
            simulation.drawLines = !simulation.drawLines;
        });

        document.getElementById('resetSimulation').addEventListener('click', () => {
            simulation.resetSimulation();
        });

        document.getElementById('toggleObstacle').addEventListener('click', () => {
            simulation.obstacle = (simulation.obstacle + 1) % 3;
            simulation.resetSimulation();
        });

        document.getElementById('togglePlot').addEventListener('click', () => {
            simulation.plot = (simulation.plot + 1) % 2;
        });

        document.getElementById('densityVariationSlider').addEventListener('input', (e) => {
            simulation.densityVariation = parseFloat(e.target.value) / 100.0;
        });

        document.getElementById('flowSpeedSlider').addEventListener('input', (e) => {
            simulation.flowSpeed = parseFloat(e.target.value) / 100.0;
            simulation.resetSimulation();
        });

        document.getElementById('viscositySlider').addEventListener('input', (e) => {
            simulation.tau = parseFloat(e.target.value) / 10.0;
        });

        document.getElementById('densityVariationSlider').value = simulation.densityVariation * 100;
        document.getElementById('flowSpeedSlider').value = simulation.flowSpeed * 100;
        document.getElementById('viscositySlider').value = simulation.tau * 10;
    </script>
</body>
</html>
